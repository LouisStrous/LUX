// This file was GENERATED by bindings.pl.

#include <cstdint>                 // for int32_t
#include <cstdlib>                 // for size_t
#include "config.h"
#include "bindings.hh"
#include "install.hh"              // for MAX_DIMS
#if HAVE_LIBSOFA_C
# include "sofa.h"
#endif

int32_t luxerror(char const*, int32_t, ...);

/// A function that wraps
///     double kepler_v(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on astron.cc
// line 3514 and may be overwritten at the next compilation.
Symbol
lux_kepler_v_f(int32_t narg, int32_t ps[])
{
  double kepler_v(double, double);
  int32_t result = lux_d_dd_iaibrq_01_2_f_(narg, ps, kepler_v);
  if (result < 0)
    luxerror("Error in kepler", 0);
  return result;
}

/// A function that wraps
///     void esmooth_asymmetric(double*, size_t, size_t, double, double*, size_t, size_t)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on fun2.cc
// line 2784 and may be overwritten at the next compilation.
Symbol
lux_esmooth_asymmetric_f(int32_t narg, int32_t ps[])
{
  void esmooth_asymmetric(double*, size_t, size_t, double, double*, size_t, size_t);
  int32_t result = lux_v_sddsd_iairq_012_f_(narg, ps, esmooth_asymmetric);
  if (result < 0)
    luxerror("Error in esmooth1", 0);
  return result;
}

/// A function that wraps
///     void esmooth_symmetric(double*, size_t, size_t, double, double*, size_t, size_t)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on fun2.cc
// line 2834 and may be overwritten at the next compilation.
Symbol
lux_esmooth_symmetric_f(int32_t narg, int32_t ps[])
{
  void esmooth_symmetric(double*, size_t, size_t, double, double*, size_t, size_t);
  int32_t result = lux_v_sddsd_iairq_012_f_(narg, ps, esmooth_symmetric);
  if (result < 0)
    luxerror("Error in esmooth2", 0);
  return result;
}

/// A function that wraps
///     int32_t gsl_fft(double*, size_t, size_t)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on fun3.cc
// line 532 and may be overwritten at the next compilation.
Symbol
lux_gsl_fft_f(int32_t narg, int32_t ps[])
{
  int32_t gsl_fft(double*, size_t, size_t);
  int32_t result = lux_i_sd_iaiarq_000_f_(narg, ps, gsl_fft);
  if (result < 0)
    luxerror("Error in fft", 0);
  return result;
}

/// A function that wraps
///     int32_t gsl_fft(double*, size_t, size_t)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on fun3.cc
// line 533 and may be overwritten at the next compilation.
Symbol
lux_gsl_fft_s(int32_t narg, int32_t ps[])
{
  int32_t gsl_fft(double*, size_t, size_t);
  int32_t result = lux_i_sd_iaia_000_s_(narg, ps, gsl_fft);
  if (result < 0)
    luxerror("Error in fft", 0);
  return result;
}

/// A function that wraps
///     int32_t gsl_fft_back(double*, size_t, size_t)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on fun3.cc
// line 563 and may be overwritten at the next compilation.
Symbol
lux_gsl_fft_back_f(int32_t narg, int32_t ps[])
{
  int32_t gsl_fft_back(double*, size_t, size_t);
  int32_t result = lux_i_sd_iaiarq_000_f_(narg, ps, gsl_fft_back);
  if (result < 0)
    luxerror("Error in fftb", 0);
  return result;
}

/// A function that wraps
///     int32_t gsl_fft_back(double*, size_t, size_t)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on fun3.cc
// line 564 and may be overwritten at the next compilation.
Symbol
lux_gsl_fft_back_s(int32_t narg, int32_t ps[])
{
  int32_t gsl_fft_back(double*, size_t, size_t);
  int32_t result = lux_i_sd_iaia_000_s_(narg, ps, gsl_fft_back);
  if (result < 0)
    luxerror("Error in fftb", 0);
  return result;
}

/// A function that wraps
///     int32_t hilbert(double*, size_t, size_t)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on fun3.cc
// line 587 and may be overwritten at the next compilation.
Symbol
lux_hilbert_f(int32_t narg, int32_t ps[])
{
  int32_t hilbert(double*, size_t, size_t);
  int32_t result = lux_i_sd_iaiarq_000_f_(narg, ps, hilbert);
  if (result < 0)
    luxerror("Error in hilbert", 0);
  return result;
}

/// A function that wraps
///     int32_t hilbert(double*, size_t, size_t)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on fun3.cc
// line 588 and may be overwritten at the next compilation.
Symbol
lux_hilbert_s(int32_t narg, int32_t ps[])
{
  int32_t hilbert(double*, size_t, size_t);
  int32_t result = lux_i_sd_iaia_000_s_(narg, ps, hilbert);
  if (result < 0)
    luxerror("Error in hilbert", 0);
  return result;
}

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauBi00(double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 70 and may be overwritten at the next compilation.
Symbol
lux_iauBi00_f(int32_t narg, int32_t ps[])
{
  void iauBi00(double*, double*, double*);
  int32_t result = lux_v_dpT3_r3_000_f_(narg, ps, iauBi00);
  if (result < 0)
    luxerror("Error in bi00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauBp00(double, double, double[3][3], double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 78 and may be overwritten at the next compilation.
Symbol
lux_iauBp00_s(int32_t narg, int32_t ps[])
{
  void iauBp00(double, double, double[3][3], double[3][3], double[3][3]);
  int32_t result = lux_v_dddp33T3_iao33op3p3qocq_0z1T3_s_(narg, ps, iauBp00);
  if (result < 0)
    luxerror("Error in bp00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauBp06(double, double, double[3][3], double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 86 and may be overwritten at the next compilation.
Symbol
lux_iauBp06_s(int32_t narg, int32_t ps[])
{
  void iauBp06(double, double, double[3][3], double[3][3], double[3][3]);
  int32_t result = lux_v_dddp33T3_iao33op3p3qocq_0z1T3_s_(narg, ps, iauBp06);
  if (result < 0)
    luxerror("Error in bp06", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauBpn2xy(double[3][3], double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 92 and may be overwritten at the next compilation.
Symbol
lux_iauBpn2xy_s(int32_t narg, int32_t ps[])
{
  void iauBpn2xy(double[3][3], double*, double*);
  int32_t result = lux_v_dp33dpdp_i33aommqocq_0T2_s_(narg, ps, iauBpn2xy);
  if (result < 0)
    luxerror("Error in bpn2xy", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2i00a(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 98 and may be overwritten at the next compilation.
Symbol
lux_iauC2i00a_f(int32_t narg, int32_t ps[])
{
  void iauC2i00a(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauC2i00a);
  if (result < 0)
    luxerror("Error in c2i00a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2i00b(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 104 and may be overwritten at the next compilation.
Symbol
lux_iauC2i00b_f(int32_t narg, int32_t ps[])
{
  void iauC2i00b(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauC2i00b);
  if (result < 0)
    luxerror("Error in c2i00b", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2i06a(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 110 and may be overwritten at the next compilation.
Symbol
lux_iauC2i06a_f(int32_t narg, int32_t ps[])
{
  void iauC2i06a(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauC2i06a);
  if (result < 0)
    luxerror("Error in c2i06a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2ibpn(double, double, double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 116 and may be overwritten at the next compilation.
Symbol
lux_iauC2ibpn_f(int32_t narg, int32_t ps[])
{
  void iauC2ibpn(double, double, double[3][3], double[3][3]);
  int32_t result = lux_v_dddp33T2_iaip3p3qrcq_0z12_f_(narg, ps, iauC2ibpn);
  if (result < 0)
    luxerror("Error in c2ibpn", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2ixy(double, double, double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 123 and may be overwritten at the next compilation.
Symbol
lux_iauC2ixy_f(int32_t narg, int32_t ps[])
{
  void iauC2ixy(double, double, double, double, double[3][3]);
  int32_t result = lux_v_dT4dp33_iaiqiqrp3p3q_0z1T3_f_(narg, ps, iauC2ixy);
  if (result < 0)
    luxerror("Error in c2ixy", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2ixys(double, double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 130 and may be overwritten at the next compilation.
Symbol
lux_iauC2ixys_f(int32_t narg, int32_t ps[])
{
  void iauC2ixys(double, double, double, double[3][3]);
  int32_t result = lux_v_dT3dp33_iaiqiqrp3p3q_0T3_f_(narg, ps, iauC2ixys);
  if (result < 0)
    luxerror("Error in c2ixys", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2s(double[3], double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 138 and may be overwritten at the next compilation.
Symbol
lux_iauC2s_f(int32_t narg, int32_t ps[])
{
  void iauC2s(double[3], double*, double*);
  int32_t result = lux_v_dp3dpdp_i3arm3p2q_011_f_(narg, ps, iauC2s);
  if (result < 0)
    luxerror("Error in c2s", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2t00a(double, double, double, double, double, double,double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 146 and may be overwritten at the next compilation.
Symbol
lux_iauC2t00a_f(int32_t narg, int32_t ps[])
{
  void iauC2t00a(double, double, double, double, double, double,double[3][3]);
  int32_t result = lux_v_dT6dp33_iaiqT3rp3p3q_0z11T4_f_(narg, ps, iauC2t00a);
  if (result < 0)
    luxerror("Error in c2t00a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2t00b(double, double, double, double, double, double,double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 154 and may be overwritten at the next compilation.
Symbol
lux_iauC2t00b_f(int32_t narg, int32_t ps[])
{
  void iauC2t00b(double, double, double, double, double, double,double[3][3]);
  int32_t result = lux_v_dT6dp33_iaiqT3rp3p3q_0z11T4_f_(narg, ps, iauC2t00b);
  if (result < 0)
    luxerror("Error in c2t00b", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2t06a(double, double, double, double, double, double,double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 163 and may be overwritten at the next compilation.
Symbol
lux_iauC2t06a_f(int32_t narg, int32_t ps[])
{
  void iauC2t06a(double, double, double, double, double, double,double[3][3]);
  int32_t result = lux_v_dT6dp33_iaiqT3rp3p3q_0z11T4_f_(narg, ps, iauC2t06a);
  if (result < 0)
    luxerror("Error in c2t06a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2tcio(double[3][3], double, double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 170 and may be overwritten at the next compilation.
Symbol
lux_iauC2tcio_f(int32_t narg, int32_t ps[])
{
  void iauC2tcio(double[3][3], double, double[3][3], double[3][3]);
  int32_t result = lux_v_dp33ddp33T2_i33aimmqiqrq_0T3_f_(narg, ps, iauC2tcio);
  if (result < 0)
    luxerror("Error in c2tcio", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2teqx(double[3][3], double, double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 177 and may be overwritten at the next compilation.
Symbol
lux_iauC2teqx_f(int32_t narg, int32_t ps[])
{
  void iauC2teqx(double[3][3], double, double[3][3], double[3][3]);
  int32_t result = lux_v_dp33ddp33T2_i33aimmqiqrq_0T3_f_(narg, ps, iauC2teqx);
  if (result < 0)
    luxerror("Error in c2teqx", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2tpe(double, double, double, double, double, double, double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 184 and may be overwritten at the next compilation.
Symbol
lux_iauC2tpe_f(int32_t narg, int32_t ps[])
{
  void iauC2tpe(double, double, double, double, double, double, double, double, double[3][3]);
  int32_t result = lux_v_dT8dp33_iaiqT4rp3p3q_0zzz1T5_f_(narg, ps, iauC2tpe);
  if (result < 0)
    luxerror("Error in c2tpe", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauC2txy(double, double, double, double, double, double, double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 191 and may be overwritten at the next compilation.
Symbol
lux_iauC2txy_f(int32_t narg, int32_t ps[])
{
  void iauC2txy(double, double, double, double, double, double, double, double, double[3][3]);
  int32_t result = lux_v_dT8dp33_iaiqT4rp3p3q_0zzz1T5_f_(narg, ps, iauC2txy);
  if (result < 0)
    luxerror("Error in c2txy", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauDtdb(double, double, double, double, double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 352 and may be overwritten at the next compilation.
Symbol
lux_iauDtdb_f(int32_t narg, int32_t ps[])
{
  double iauDtdb(double, double, double, double, double, double);
  int32_t result = lux_d_dT6_iaiT4rq_0z1T4_5_f_(narg, ps, iauDtdb);
  if (result < 0)
    luxerror("Error in dtdb", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double do_iauEe00(double, double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 362 and may be overwritten at the next compilation.
Symbol
lux_do_iauEe00_f(int32_t narg, int32_t ps[])
{
  double do_iauEe00(double, double, double);
  int32_t result = lux_d_dT3_iaiqiqrq_012_f_(narg, ps, do_iauEe00);
  if (result < 0)
    luxerror("Error in ee00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauEe00a(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 368 and may be overwritten at the next compilation.
Symbol
lux_iauEe00a_f(int32_t narg, int32_t ps[])
{
  double iauEe00a(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauEe00a);
  if (result < 0)
    luxerror("Error in ee00a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauEe00b(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 374 and may be overwritten at the next compilation.
Symbol
lux_iauEe00b_f(int32_t narg, int32_t ps[])
{
  double iauEe00b(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauEe00b);
  if (result < 0)
    luxerror("Error in ee00b", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauEe06a(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 380 and may be overwritten at the next compilation.
Symbol
lux_iauEe06a_f(int32_t narg, int32_t ps[])
{
  double iauEe06a(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauEe06a);
  if (result < 0)
    luxerror("Error in ee06a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauEect00(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 386 and may be overwritten at the next compilation.
Symbol
lux_iauEect00_f(int32_t narg, int32_t ps[])
{
  double iauEect00(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauEect00);
  if (result < 0)
    luxerror("Error in eect00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauEform(int32_t, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 395 and may be overwritten at the next compilation.
Symbol
lux_iauEform_f(int32_t narg, int32_t ps[])
{
  int32_t iauEform(int32_t, double*, double*);
  int32_t result = lux_i_idpdp_iarp2q_011_f_(narg, ps, iauEform);
  if (result < 0)
    luxerror("Error in eform", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauEo06a(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 401 and may be overwritten at the next compilation.
Symbol
lux_iauEo06a_f(int32_t narg, int32_t ps[])
{
  double iauEo06a(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauEo06a);
  if (result < 0)
    luxerror("Error in eo06a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauEors(double[3][3], double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 407 and may be overwritten at the next compilation.
Symbol
lux_iauEors_f(int32_t narg, int32_t ps[])
{
  double iauEors(double[3][3], double);
  int32_t result = lux_d_dp33d_i33aimmqrcq_01_2_f_(narg, ps, iauEors);
  if (result < 0)
    luxerror("Error in eors", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauEpb(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 412 and may be overwritten at the next compilation.
Symbol
lux_iauEpb_f(int32_t narg, int32_t ps[])
{
  double iauEpb(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauEpb);
  if (result < 0)
    luxerror("Error in epb", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauEpj(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 439 and may be overwritten at the next compilation.
Symbol
lux_iauEpj_f(int32_t narg, int32_t ps[])
{
  double iauEpj(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauEpj);
  if (result < 0)
    luxerror("Error in epj", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauEpv00(double, double, double[2][3], double[2][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 470 and may be overwritten at the next compilation.
Symbol
lux_iauEpv00_s(int32_t narg, int32_t ps[])
{
  int32_t iauEpv00(double, double, double[2][3], double[2][3]);
  int32_t result = lux_i_dddp23T2_iaop2p3qocq_0z12_s_(narg, ps, iauEpv00);
  if (result < 0)
    luxerror("Error in epv00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauEqeq94(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 476 and may be overwritten at the next compilation.
Symbol
lux_iauEqeq94_f(int32_t narg, int32_t ps[])
{
  double iauEqeq94(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauEqeq94);
  if (result < 0)
    luxerror("Error in eqeq94", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauEra00(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 482 and may be overwritten at the next compilation.
Symbol
lux_iauEra00_f(int32_t narg, int32_t ps[])
{
  double iauEra00(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauEra00);
  if (result < 0)
    luxerror("Error in era00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFad03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 491 and may be overwritten at the next compilation.
Symbol
lux_iauFad03_f(int32_t narg, int32_t ps[])
{
  double iauFad03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFad03);
  if (result < 0)
    luxerror("Error in fad03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFae03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 500 and may be overwritten at the next compilation.
Symbol
lux_iauFae03_f(int32_t narg, int32_t ps[])
{
  double iauFae03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFae03);
  if (result < 0)
    luxerror("Error in fae03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFaf03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 509 and may be overwritten at the next compilation.
Symbol
lux_iauFaf03_f(int32_t narg, int32_t ps[])
{
  double iauFaf03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFaf03);
  if (result < 0)
    luxerror("Error in faf03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFaju03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 518 and may be overwritten at the next compilation.
Symbol
lux_iauFaju03_f(int32_t narg, int32_t ps[])
{
  double iauFaju03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFaju03);
  if (result < 0)
    luxerror("Error in faju03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFal03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 527 and may be overwritten at the next compilation.
Symbol
lux_iauFal03_f(int32_t narg, int32_t ps[])
{
  double iauFal03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFal03);
  if (result < 0)
    luxerror("Error in fal03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFalp03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 536 and may be overwritten at the next compilation.
Symbol
lux_iauFalp03_f(int32_t narg, int32_t ps[])
{
  double iauFalp03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFalp03);
  if (result < 0)
    luxerror("Error in falp03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFama03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 545 and may be overwritten at the next compilation.
Symbol
lux_iauFama03_f(int32_t narg, int32_t ps[])
{
  double iauFama03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFama03);
  if (result < 0)
    luxerror("Error in fama03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFame03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 554 and may be overwritten at the next compilation.
Symbol
lux_iauFame03_f(int32_t narg, int32_t ps[])
{
  double iauFame03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFame03);
  if (result < 0)
    luxerror("Error in fame03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFane03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 563 and may be overwritten at the next compilation.
Symbol
lux_iauFane03_f(int32_t narg, int32_t ps[])
{
  double iauFane03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFane03);
  if (result < 0)
    luxerror("Error in fane03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFaom03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 572 and may be overwritten at the next compilation.
Symbol
lux_iauFaom03_f(int32_t narg, int32_t ps[])
{
  double iauFaom03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFaom03);
  if (result < 0)
    luxerror("Error in faom03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFapa03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 581 and may be overwritten at the next compilation.
Symbol
lux_iauFapa03_f(int32_t narg, int32_t ps[])
{
  double iauFapa03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFapa03);
  if (result < 0)
    luxerror("Error in fapa03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFasa03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 590 and may be overwritten at the next compilation.
Symbol
lux_iauFasa03_f(int32_t narg, int32_t ps[])
{
  double iauFasa03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFasa03);
  if (result < 0)
    luxerror("Error in fasa03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFaur03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 599 and may be overwritten at the next compilation.
Symbol
lux_iauFaur03_f(int32_t narg, int32_t ps[])
{
  double iauFaur03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFaur03);
  if (result < 0)
    luxerror("Error in faur03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauFave03(double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 608 and may be overwritten at the next compilation.
Symbol
lux_iauFave03_f(int32_t narg, int32_t ps[])
{
  double iauFave03(double);
  int32_t result = lux_d_d_iarq_0_1_f_(narg, ps, iauFave03);
  if (result < 0)
    luxerror("Error in fave03", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauFk52h(double, double, double, double, double, double, double*, double*, double*, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 620 and may be overwritten at the next compilation.
Symbol
lux_iauFk52h_s(int32_t narg, int32_t ps[])
{
  void iauFk52h(double, double, double, double, double, double, double*, double*, double*, double*, double*, double*);
  int32_t result = lux_v_dT6dpT6_iaiqT5oqT6_0T11_s_(narg, ps, iauFk52h);
  if (result < 0)
    luxerror("Error in fk52h", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauFk5hip(double[3][3], double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 625 and may be overwritten at the next compilation.
Symbol
lux_iauFk5hip_s(int32_t narg, int32_t ps[])
{
  void iauFk5hip(double[3][3], double[3]);
  int32_t result = lux_v_dp3dp_o33o3_01_s_(narg, ps, iauFk5hip);
  if (result < 0)
    luxerror("Error in fk5hip", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauFk5hz(double, double, double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 634 and may be overwritten at the next compilation.
Symbol
lux_iauFk5hz_s(int32_t narg, int32_t ps[])
{
  void iauFk5hz(double, double, double, double, double*, double*);
  int32_t result = lux_v_dT4dpdp_iaiqiqoqoq_0T2z34_s_(narg, ps, iauFk5hz);
  if (result < 0)
    luxerror("Error in fk5hz", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauFw2m(double, double, double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 640 and may be overwritten at the next compilation.
Symbol
lux_iauFw2m_f(int32_t narg, int32_t ps[])
{
  void iauFw2m(double, double, double, double, double[3][3]);
  int32_t result = lux_v_dT4dp33_iaiqT3rp3p3q_0T4_f_(narg, ps, iauFw2m);
  if (result < 0)
    luxerror("Error in fw2m", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauFw2xy(double, double, double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 647 and may be overwritten at the next compilation.
Symbol
lux_iauFw2xy_s(int32_t narg, int32_t ps[])
{
  void iauFw2xy(double, double, double, double, double*, double*);
  int32_t result = lux_v_dT4dpdp_iaiqT3oqoq_0T5_s_(narg, ps, iauFw2xy);
  if (result < 0)
    luxerror("Error in fw2xy", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauGc2gd(int32_t, double[3], double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 654 and may be overwritten at the next compilation.
Symbol
lux_iauGc2gd_f(int32_t narg, int32_t ps[])
{
  int32_t iauGc2gd(int32_t, double[3], double*, double*, double*);
  int32_t result = lux_i_idp3dpT3_ii3arcq_0T222_f_(narg, ps, iauGc2gd);
  if (result < 0)
    luxerror("Error in gc2gd", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauGc2gde(double, double, double[3], double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 661 and may be overwritten at the next compilation.
Symbol
lux_iauGc2gde_f(int32_t narg, int32_t ps[])
{
  int32_t iauGc2gde(double, double, double[3], double*, double*, double*);
  int32_t result = lux_v_dddp3dpT3_i3aiirq_120333_f_(narg, ps, iauGc2gde);
  if (result < 0)
    luxerror("Error in gc2gde", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauGd2gc(int32_t, double, double, double, double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 668 and may be overwritten at the next compilation.
Symbol
lux_iauGd2gc_f(int32_t narg, int32_t ps[])
{
  int32_t iauGd2gc(int32_t, double, double, double, double[3]);
  int32_t result = lux_i_idT3dp3_i3airq_10002_f_(narg, ps, iauGd2gc);
  if (result < 0)
    luxerror("Error in gd2gc", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauGd2gce(double, double, double, double, double, double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 675 and may be overwritten at the next compilation.
Symbol
lux_iauGd2gce_f(int32_t narg, int32_t ps[])
{
  int32_t iauGd2gce(double, double, double, double, double, double[3]);
  int32_t result = lux_i_dT5dp3_i3aiirq_120003_f_(narg, ps, iauGd2gce);
  if (result < 0)
    luxerror("Error in gd2gce", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauGmst00(double, double, double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 685 and may be overwritten at the next compilation.
Symbol
lux_iauGmst00_f(int32_t narg, int32_t ps[])
{
  double iauGmst00(double, double, double, double);
  int32_t result = lux_d_dT4_iaiqrq_01_2_f_(narg, ps, iauGmst00);
  if (result < 0)
    luxerror("Error in gmst00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauGmst06(double, double, double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 695 and may be overwritten at the next compilation.
Symbol
lux_iauGmst06_f(int32_t narg, int32_t ps[])
{
  double iauGmst06(double, double, double, double);
  int32_t result = lux_d_dT4_iaiqrq_01_2_f_(narg, ps, iauGmst06);
  if (result < 0)
    luxerror("Error in gmst06", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauGmst82(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 701 and may be overwritten at the next compilation.
Symbol
lux_iauGmst82_f(int32_t narg, int32_t ps[])
{
  double iauGmst82(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauGmst82);
  if (result < 0)
    luxerror("Error in gmst82", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauGst00a(double, double, double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 711 and may be overwritten at the next compilation.
Symbol
lux_iauGst00a_f(int32_t narg, int32_t ps[])
{
  double iauGst00a(double, double, double, double);
  int32_t result = lux_d_dT4_iaiqrq_01_2_f_(narg, ps, iauGst00a);
  if (result < 0)
    luxerror("Error in gst00a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauGst00b(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 718 and may be overwritten at the next compilation.
Symbol
lux_iauGst00b_f(int32_t narg, int32_t ps[])
{
  double iauGst00b(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauGst00b);
  if (result < 0)
    luxerror("Error in gst00b", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauGst06(double, double, double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 728 and may be overwritten at the next compilation.
Symbol
lux_iauGst06_f(int32_t narg, int32_t ps[])
{
  double iauGst06(double, double, double, double, double[3][3]);
  int32_t result = lux_d_dT4dp33_iaiqip3p3qrq_00112_3_f_(narg, ps, iauGst06);
  if (result < 0)
    luxerror("Error in gst06", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauGst06a(double, double, double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 738 and may be overwritten at the next compilation.
Symbol
lux_iauGst06a_f(int32_t narg, int32_t ps[])
{
  double iauGst06a(double, double, double, double);
  int32_t result = lux_d_dT4_iaiqrq_01_2_f_(narg, ps, iauGst06a);
  if (result < 0)
    luxerror("Error in gst06a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauGst94(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 744 and may be overwritten at the next compilation.
Symbol
lux_iauGst94_f(int32_t narg, int32_t ps[])
{
  double iauGst94(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauGst94);
  if (result < 0)
    luxerror("Error in gst94", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauH2fk5(double, double, double, double, double, double, double*, double*, double*, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 756 and may be overwritten at the next compilation.
Symbol
lux_iauH2fk5_s(int32_t narg, int32_t ps[])
{
  void iauH2fk5(double, double, double, double, double, double, double*, double*, double*, double*, double*, double*);
  int32_t result = lux_v_dT6dpT6_iaiqT5oqT6_0T11_s_(narg, ps, iauH2fk5);
  if (result < 0)
    luxerror("Error in h2fk5", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauHfk5z(double, double, double, double, double*, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 765 and may be overwritten at the next compilation.
Symbol
lux_iauHfk5z_s(int32_t narg, int32_t ps[])
{
  void iauHfk5z(double, double, double, double, double*, double*, double*, double*);
  int32_t result = lux_v_dT4dpT4_iaiqiqoqT4_0T2z3T6_s_(narg, ps, iauHfk5z);
  if (result < 0)
    luxerror("Error in hfk5z", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauIr(double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 770 and may be overwritten at the next compilation.
Symbol
lux_iauIr_f(int32_t narg, int32_t ps[])
{
  void iauIr(double[3][3]);
  int32_t result = lux_v_dp33_r33_0_f_(narg, ps, iauIr);
  if (result < 0)
    luxerror("Error in ir", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauJd2cal(double, double, int32_t*, int32_t*, int32_t*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 780 and may be overwritten at the next compilation.
Symbol
lux_iauJd2cal_f(int32_t narg, int32_t ps[])
{
  int32_t iauJd2cal(double, double, int32_t*, int32_t*, int32_t*, double*);
  int32_t result = lux_i_ddipT3dp_iarp3q_0z1111_f_(narg, ps, iauJd2cal);
  if (result < 0)
    luxerror("Error in jd2cal", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauNum00a(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 786 and may be overwritten at the next compilation.
Symbol
lux_iauNum00a_f(int32_t narg, int32_t ps[])
{
  void iauNum00a(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauNum00a);
  if (result < 0)
    luxerror("Error in num00a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauNum00b(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 792 and may be overwritten at the next compilation.
Symbol
lux_iauNum00b_f(int32_t narg, int32_t ps[])
{
  void iauNum00b(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauNum00b);
  if (result < 0)
    luxerror("Error in num00b", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauNum06a(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 798 and may be overwritten at the next compilation.
Symbol
lux_iauNum06a_f(int32_t narg, int32_t ps[])
{
  void iauNum06a(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauNum06a);
  if (result < 0)
    luxerror("Error in num06a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauNumat(double, double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 804 and may be overwritten at the next compilation.
Symbol
lux_iauNumat_f(int32_t narg, int32_t ps[])
{
  void iauNumat(double, double, double, double[3][3]);
  int32_t result = lux_v_dT3dp33_iaiqiqrp3p3q_0T3_f_(narg, ps, iauNumat);
  if (result < 0)
    luxerror("Error in numat", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauNut00a(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 812 and may be overwritten at the next compilation.
Symbol
lux_iauNut00a_s(int32_t narg, int32_t ps[])
{
  void iauNut00a(double, double, double*, double*);
  int32_t result = lux_v_dddpdp_iaoqoq_0z12_s_(narg, ps, iauNut00a);
  if (result < 0)
    luxerror("Error in nut00a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauNut00b(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 819 and may be overwritten at the next compilation.
Symbol
lux_iauNut00b_s(int32_t narg, int32_t ps[])
{
  void iauNut00b(double, double, double*, double*);
  int32_t result = lux_v_dddpdp_iaoqoq_0z12_s_(narg, ps, iauNut00b);
  if (result < 0)
    luxerror("Error in nut00b", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauNut06a(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 827 and may be overwritten at the next compilation.
Symbol
lux_iauNut06a_s(int32_t narg, int32_t ps[])
{
  void iauNut06a(double, double, double*, double*);
  int32_t result = lux_v_dddpdp_iaoqoq_0z12_s_(narg, ps, iauNut06a);
  if (result < 0)
    luxerror("Error in nut06a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauNut80(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 834 and may be overwritten at the next compilation.
Symbol
lux_iauNut80_s(int32_t narg, int32_t ps[])
{
  void iauNut80(double, double, double*, double*);
  int32_t result = lux_v_dddpdp_iaoqoq_0z12_s_(narg, ps, iauNut80);
  if (result < 0)
    luxerror("Error in nut80", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauNutm80(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 841 and may be overwritten at the next compilation.
Symbol
lux_iauNutm80_f(int32_t narg, int32_t ps[])
{
  void iauNutm80(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauNutm80);
  if (result < 0)
    luxerror("Error in nutm80", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauObl06(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 848 and may be overwritten at the next compilation.
Symbol
lux_iauObl06_f(int32_t narg, int32_t ps[])
{
  double iauObl06(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauObl06);
  if (result < 0)
    luxerror("Error in obl06", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauObl80(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 854 and may be overwritten at the next compilation.
Symbol
lux_iauObl80_f(int32_t narg, int32_t ps[])
{
  double iauObl80(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauObl80);
  if (result < 0)
    luxerror("Error in obl80", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauP06e(double, double, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 865 and may be overwritten at the next compilation.
Symbol
lux_iauP06e_s(int32_t narg, int32_t ps[])
{
  void iauP06e(double, double, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*, double*);
  int32_t result = lux_v_dddpT16_iaoqT16_0z1T16_s_(narg, ps, iauP06e);
  if (result < 0)
    luxerror("Error in p06e", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauP2s(double[3], double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 871 and may be overwritten at the next compilation.
Symbol
lux_iauP2s_f(int32_t narg, int32_t ps[])
{
  void iauP2s(double[3], double*, double*, double*);
  int32_t result = lux_v_dp3dpT3_i3arq_0111_f_(narg, ps, iauP2s);
  if (result < 0)
    luxerror("Error in p2s", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauPap(double[3], double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 877 and may be overwritten at the next compilation.
Symbol
lux_iauPap_f(int32_t narg, int32_t ps[])
{
  double iauPap(double[3], double[3]);
  int32_t result = lux_d_dp3dp3_i3aiqrm3q_01_2_f_(narg, ps, iauPap);
  if (result < 0)
    luxerror("Error in pap", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauPas(double, double, double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 886 and may be overwritten at the next compilation.
Symbol
lux_iauPas_f(int32_t narg, int32_t ps[])
{
  double iauPas(double, double, double, double);
  int32_t result = lux_d_dT4_iaiqT3rq_0T3_4_f_(narg, ps, iauPas);
  if (result < 0)
    luxerror("Error in pas", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPb06(double, double, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 893 and may be overwritten at the next compilation.
Symbol
lux_iauPb06_s(int32_t narg, int32_t ps[])
{
  void iauPb06(double, double, double*, double*, double*);
  int32_t result = lux_v_dddpT3_iaoqT3_0z1T3_s_(narg, ps, iauPb06);
  if (result < 0)
    luxerror("Error in pb06", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauPdp(double[3], double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 898 and may be overwritten at the next compilation.
Symbol
lux_iauPdp_f(int32_t narg, int32_t ps[])
{
  double iauPdp(double[3], double[3]);
  int32_t result = lux_d_dp3dp3_i3aiqrm3q_01_2_f_(narg, ps, iauPdp);
  if (result < 0)
    luxerror("Error in pdp", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPfw06(double, double, double*, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 904 and may be overwritten at the next compilation.
Symbol
lux_iauPfw06_s(int32_t narg, int32_t ps[])
{
  void iauPfw06(double, double, double*, double*, double*, double*);
  int32_t result = lux_v_dddpT4_iaoqT4_0z1T4_s_(narg, ps, iauPfw06);
  if (result < 0)
    luxerror("Error in pfw06", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauPlan94(double, double, int32_t, double[2][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 912 and may be overwritten at the next compilation.
Symbol
lux_iauPlan94_f(int32_t narg, int32_t ps[])
{
  int32_t iauPlan94(double, double, int32_t, double[2][3]);
  int32_t result = lux_i_ddidp23_iairp3p2q_0z12_f_(narg, ps, iauPlan94);
  if (result < 0)
    luxerror("Error in plan94", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauPm(double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 918 and may be overwritten at the next compilation.
Symbol
lux_iauPm_f(int32_t narg, int32_t ps[])
{
  double iauPm(double[3]);
  int32_t result = lux_d_dp3_i3arm3q_0_1_f_(narg, ps, iauPm);
  if (result < 0)
    luxerror("Error in pm", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPmat00(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 925 and may be overwritten at the next compilation.
Symbol
lux_iauPmat00_f(int32_t narg, int32_t ps[])
{
  void iauPmat00(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauPmat00);
  if (result < 0)
    luxerror("Error in pmat00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPmat06(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 932 and may be overwritten at the next compilation.
Symbol
lux_iauPmat06_f(int32_t narg, int32_t ps[])
{
  void iauPmat06(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauPmat06);
  if (result < 0)
    luxerror("Error in pmat06", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPmat76(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 938 and may be overwritten at the next compilation.
Symbol
lux_iauPmat76_f(int32_t narg, int32_t ps[])
{
  void iauPmat76(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauPmat76);
  if (result < 0)
    luxerror("Error in pmat76", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPn(double[3], double*, double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 943 and may be overwritten at the next compilation.
Symbol
lux_iauPn_s(int32_t narg, int32_t ps[])
{
  void iauPn(double[3], double*, double[3]);
  int32_t result = lux_v_dp3dpdp3_i3aomqoq_0T2_s_(narg, ps, iauPn);
  if (result < 0)
    luxerror("Error in pn", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPn00(double, double, double, double, double*, double[3][3], double[3][3], double[3][3], double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 952 and may be overwritten at the next compilation.
Symbol
lux_iauPn00_s(int32_t narg, int32_t ps[])
{
  void iauPn00(double, double, double, double, double*, double[3][3], double[3][3], double[3][3], double[3][3], double[3][3]);
  int32_t result = lux_v_dT4dpdp3T5_iaiqiqoqop3p3qocqT4_0z1T8_s_(narg, ps, iauPn00);
  if (result < 0)
    luxerror("Error in pn00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPn00a(double, double, double*, double*, double*, double[3][3], double[3][3], double[3][3], double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 961 and may be overwritten at the next compilation.
Symbol
lux_iauPn00a_s(int32_t narg, int32_t ps[])
{
  void iauPn00a(double, double, double*, double*, double*, double[3][3], double[3][3], double[3][3], double[3][3], double[3][3]);
  int32_t result = lux_v_dddpT3dp33T5_iaoqT3op3p3qocqT4_0z1T8_s_(narg, ps, iauPn00a);
  if (result < 0)
    luxerror("Error in pn00a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPn00b(double, double, double*, double*, double*, double[3][3], double[3][3], double[3][3], double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 970 and may be overwritten at the next compilation.
Symbol
lux_iauPn00b_s(int32_t narg, int32_t ps[])
{
  void iauPn00b(double, double, double*, double*, double*, double[3][3], double[3][3], double[3][3], double[3][3], double[3][3]);
  int32_t result = lux_v_dddpT3dp33T5_iaoqT3op3p3qocqT4_0z1T8_s_(narg, ps, iauPn00b);
  if (result < 0)
    luxerror("Error in pn00b", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPn06(double, double, double, double, double*, double[3][3], double[3][3], double[3][3], double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 979 and may be overwritten at the next compilation.
Symbol
lux_iauPn06_s(int32_t narg, int32_t ps[])
{
  void iauPn06(double, double, double, double, double*, double[3][3], double[3][3], double[3][3], double[3][3], double[3][3]);
  int32_t result = lux_v_dT4dpdp3T5_iaiqiqoqop3p3qocqT4_0z1T8_s_(narg, ps, iauPn06);
  if (result < 0)
    luxerror("Error in pn06", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPn06a(double, double, double*, double*, double*, double[3][3], double[3][3], double[3][3], double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 989 and may be overwritten at the next compilation.
Symbol
lux_iauPn06a_s(int32_t narg, int32_t ps[])
{
  void iauPn06a(double, double, double*, double*, double*, double[3][3], double[3][3], double[3][3], double[3][3], double[3][3]);
  int32_t result = lux_v_dddpT3dp33T5_iaoqT3op3p3qocqT4_0z1T8_s_(narg, ps, iauPn06a);
  if (result < 0)
    luxerror("Error in pn06a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPnm00a(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 995 and may be overwritten at the next compilation.
Symbol
lux_iauPnm00a_f(int32_t narg, int32_t ps[])
{
  void iauPnm00a(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauPnm00a);
  if (result < 0)
    luxerror("Error in pnm00a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPnm00b(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1001 and may be overwritten at the next compilation.
Symbol
lux_iauPnm00b_f(int32_t narg, int32_t ps[])
{
  void iauPnm00b(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauPnm00b);
  if (result < 0)
    luxerror("Error in pnm00b", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPnm06a(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1008 and may be overwritten at the next compilation.
Symbol
lux_iauPnm06a_f(int32_t narg, int32_t ps[])
{
  void iauPnm06a(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauPnm06a);
  if (result < 0)
    luxerror("Error in pnm06a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPnm80(double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1015 and may be overwritten at the next compilation.
Symbol
lux_iauPnm80_f(int32_t narg, int32_t ps[])
{
  void iauPnm80(double, double, double[3][3]);
  int32_t result = lux_v_dddp33_iarp3p3q_0z1_f_(narg, ps, iauPnm80);
  if (result < 0)
    luxerror("Error in pnm80", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPom00(double, double, double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1021 and may be overwritten at the next compilation.
Symbol
lux_iauPom00_f(int32_t narg, int32_t ps[])
{
  void iauPom00(double, double, double, double[3][3]);
  int32_t result = lux_v_dT3dp33_iaiqiqrp3p3q_0T3_f_(narg, ps, iauPom00);
  if (result < 0)
    luxerror("Error in pom00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPr00(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1027 and may be overwritten at the next compilation.
Symbol
lux_iauPr00_s(int32_t narg, int32_t ps[])
{
  void iauPr00(double, double, double*, double*);
  int32_t result = lux_v_dddpdp_iaoqoq_0z12_s_(narg, ps, iauPr00);
  if (result < 0)
    luxerror("Error in pr00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPrec76(double, double, double, double, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1038 and may be overwritten at the next compilation.
Symbol
lux_iauPrec76_s(int32_t narg, int32_t ps[])
{
  void iauPrec76(double, double, double, double, double*, double*, double*);
  int32_t result = lux_v_dT4dpT3_iaiqoqT3_0z1z2T4_s_(narg, ps, iauPrec76);
  if (result < 0)
    luxerror("Error in prec76", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPv2s(double[2][3], double*, double*, double*, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1046 and may be overwritten at the next compilation.
Symbol
lux_iauPv2s_s(int32_t narg, int32_t ps[])
{
  void iauPv2s(double[2][3], double*, double*, double*, double*, double*, double*);
  int32_t result = lux_v_dp23dpT6_iD23aommqocqT5_0T6_s_(narg, ps, iauPv2s);
  if (result < 0)
    luxerror("Error in pv25", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPvdpv(double[2][3], double[2][3], double[2])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1051 and may be overwritten at the next compilation.
Symbol
lux_iauPvdpv_f(int32_t narg, int32_t ps[])
{
  void iauPvdpv(double[2][3], double[2][3], double[2]);
  int32_t result = lux_v_dp23T2dp2_i23aiqrkmq_0T2_f_(narg, ps, iauPvdpv);
  if (result < 0)
    luxerror("Error in pvdpv", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPvm(double[2][3], double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1058 and may be overwritten at the next compilation.
Symbol
lux_iauPvm_s(int32_t narg, int32_t ps[])
{
  void iauPvm(double[2][3], double*, double*);
  int32_t result = lux_v_dp23dpdp_i23aommqocq_0T2_s_(narg, ps, iauPvm);
  if (result < 0)
    luxerror("Error in pvm", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauPvstar(double[2][3], double*, double*, double*, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1067 and may be overwritten at the next compilation.
Symbol
lux_iauPvstar_s(int32_t narg, int32_t ps[])
{
  int32_t iauPvstar(double[2][3], double*, double*, double*, double*, double*, double*);
  int32_t result = lux_i_dp23dpT6_i23aom2m3qomqT5_0T6_s_(narg, ps, iauPvstar);
  if (result < 0)
    luxerror("Error in pvstar", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPvxpv(double[2][3], double[2][3], double[2][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1072 and may be overwritten at the next compilation.
Symbol
lux_iauPvxpv_f(int32_t narg, int32_t ps[])
{
  void iauPvxpv(double[2][3], double[2][3], double[2][3]);
  int32_t result = lux_v_dp23T3_i23aiqrq_0T2_f_(narg, ps, iauPvxpv);
  if (result < 0)
    luxerror("Error in pvxpv", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauPxp(double[3], double[3], double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1077 and may be overwritten at the next compilation.
Symbol
lux_iauPxp_f(int32_t narg, int32_t ps[])
{
  void iauPxp(double[3], double[3], double[3]);
  int32_t result = lux_v_dp3T3_i3aiqrq_0T2_f_(narg, ps, iauPxp);
  if (result < 0)
    luxerror("Error in pxp", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauRm2v(double[3][3], double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1086 and may be overwritten at the next compilation.
Symbol
lux_iauRm2v_f(int32_t narg, int32_t ps[])
{
  void iauRm2v(double[3][3], double[3]);
  int32_t result = lux_v_dp33dp3_i33armq_01_f_(narg, ps, iauRm2v);
  if (result < 0)
    luxerror("Error in rm2v", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauRxp(double[3][3], double[3], double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1091 and may be overwritten at the next compilation.
Symbol
lux_iauRxp_f(int32_t narg, int32_t ps[])
{
  void iauRxp(double[3][3], double[3], double[3]);
  int32_t result = lux_v_dp33dp3T2_i33aimqrcq_0T2_f_(narg, ps, iauRxp);
  if (result < 0)
    luxerror("Error in rxp", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauRxr(double[3][3], double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1096 and may be overwritten at the next compilation.
Symbol
lux_iauRxr_f(int32_t narg, int32_t ps[])
{
  void iauRxr(double[3][3], double[3][3], double[3][3]);
  int32_t result = lux_v_dp33T3_i33aiqrq_0T2_f_(narg, ps, iauRxr);
  if (result < 0)
    luxerror("Error in rxr", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauRv2m(double[3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1104 and may be overwritten at the next compilation.
Symbol
lux_iauRv2m_f(int32_t narg, int32_t ps[])
{
  void iauRv2m(double[3], double[3][3]);
  int32_t result = lux_v_dp3dp33_i3arp3q_01_f_(narg, ps, iauRv2m);
  if (result < 0)
    luxerror("Error in rv2m", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauRx(double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1109 and may be overwritten at the next compilation.
Symbol
lux_iauRx_s(int32_t narg, int32_t ps[])
{
  void iauRx(double, double[3][3]);
  int32_t result = lux_v_ddp33_iao33q_01_s_(narg, ps, iauRx);
  if (result < 0)
    luxerror("Error in rx", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauRxpv(double[3][3], double[2][3], double[2][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1114 and may be overwritten at the next compilation.
Symbol
lux_iauRxpv_f(int32_t narg, int32_t ps[])
{
  void iauRxpv(double[3][3], double[2][3], double[2][3]);
  int32_t result = lux_v_dp33dp23T2_i33aim3p2qrcq_0T2_f_(narg, ps, iauRxpv);
  if (result < 0)
    luxerror("Error in rxpv", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauRy(double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1119 and may be overwritten at the next compilation.
Symbol
lux_iauRy_s(int32_t narg, int32_t ps[])
{
  void iauRy(double, double[3][3]);
  int32_t result = lux_v_ddp33_iao33q_01_s_(narg, ps, iauRy);
  if (result < 0)
    luxerror("Error in ry", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauRz(double, double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1124 and may be overwritten at the next compilation.
Symbol
lux_iauRz_s(int32_t narg, int32_t ps[])
{
  void iauRz(double, double[3][3]);
  int32_t result = lux_v_ddp33_iao33q_01_s_(narg, ps, iauRz);
  if (result < 0)
    luxerror("Error in rz", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double do_iauS00(double, double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1135 and may be overwritten at the next compilation.
Symbol
lux_do_iauS00_f(int32_t narg, int32_t ps[])
{
  double do_iauS00(double, double, double);
  int32_t result = lux_d_dT3_iaiqiqrq_012_f_(narg, ps, do_iauS00);
  if (result < 0)
    luxerror("Error in s00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauS00a(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1141 and may be overwritten at the next compilation.
Symbol
lux_iauS00a_f(int32_t narg, int32_t ps[])
{
  double iauS00a(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauS00a);
  if (result < 0)
    luxerror("Error in s00a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauS00b(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1147 and may be overwritten at the next compilation.
Symbol
lux_iauS00b_f(int32_t narg, int32_t ps[])
{
  double iauS00b(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauS00b);
  if (result < 0)
    luxerror("Error in s00b", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double do_iauS06(double, double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1158 and may be overwritten at the next compilation.
Symbol
lux_do_iauS06_f(int32_t narg, int32_t ps[])
{
  double do_iauS06(double, double, double);
  int32_t result = lux_d_dT3_iaiqiqrq_012_f_(narg, ps, do_iauS06);
  if (result < 0)
    luxerror("Error in s06", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauS06a(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1164 and may be overwritten at the next compilation.
Symbol
lux_iauS06a_f(int32_t narg, int32_t ps[])
{
  double iauS06a(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauS06a);
  if (result < 0)
    luxerror("Error in s06a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauS2c(double, double, double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1170 and may be overwritten at the next compilation.
Symbol
lux_iauS2c_f(int32_t narg, int32_t ps[])
{
  void iauS2c(double, double, double[3]);
  int32_t result = lux_v_dddp3_iaiqrp3q_0T2_f_(narg, ps, iauS2c);
  if (result < 0)
    luxerror("Error in S2C", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauS2p(double, double, double, double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1176 and may be overwritten at the next compilation.
Symbol
lux_iauS2p_f(int32_t narg, int32_t ps[])
{
  void iauS2p(double, double, double, double[3]);
  int32_t result = lux_v_dT3dp3_iaiqiqrp3q_0T3_f_(narg, ps, iauS2p);
  if (result < 0)
    luxerror("Error in s2p", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauS2pv(double, double, double, double, double, double, double[2][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1184 and may be overwritten at the next compilation.
Symbol
lux_iauS2pv_f(int32_t narg, int32_t ps[])
{
  void iauS2pv(double, double, double, double, double, double, double[2][3]);
  int32_t result = lux_v_dT6dp23_iaiqT5op2p3q_0T6_f_(narg, ps, iauS2pv);
  if (result < 0)
    luxerror("Error in s2pv", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauSepp(double[3], double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1189 and may be overwritten at the next compilation.
Symbol
lux_iauSepp_f(int32_t narg, int32_t ps[])
{
  double iauSepp(double[3], double[3]);
  int32_t result = lux_d_dp3dp3_i3aiqrm3q_01_2_f_(narg, ps, iauSepp);
  if (result < 0)
    luxerror("Error in sepp", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauSeps(double, double, double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1196 and may be overwritten at the next compilation.
Symbol
lux_iauSeps_f(int32_t narg, int32_t ps[])
{
  double iauSeps(double, double, double, double);
  int32_t result = lux_d_dT4_iaiqT3rq_0T3_4_f_(narg, ps, iauSeps);
  if (result < 0)
    luxerror("Error in seps", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     double iauSp00(double, double)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1203 and may be overwritten at the next compilation.
Symbol
lux_iauSp00_f(int32_t narg, int32_t ps[])
{
  double iauSp00(double, double);
  int32_t result = lux_d_dd_iarq_0z_1_f_(narg, ps, iauSp00);
  if (result < 0)
    luxerror("Error in sp00", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauStarpm(double, double, double, double, double, double, double, double, double, double, double*, double*, double*, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1212 and may be overwritten at the next compilation.
Symbol
lux_iauStarpm_s(int32_t narg, int32_t ps[])
{
  int32_t iauStarpm(double, double, double, double, double, double, double, double, double, double, double*, double*, double*, double*, double*, double*);
  int32_t result = lux_i_dT10dpT6_iaiqT7oqT6_0T6z7z8T13_s_(narg, ps, iauStarpm);
  if (result < 0)
    luxerror("Error in starpm", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauStarpv(double, double, double, double, double, double, double[2][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1217 and may be overwritten at the next compilation.
Symbol
lux_iauStarpv_f(int32_t narg, int32_t ps[])
{
  int32_t iauStarpv(double, double, double, double, double, double, double[2][3]);
  int32_t result = lux_i_dT6dp23_iaiqT5op2p3q_0T6_f_(narg, ps, iauStarpv);
  if (result < 0)
    luxerror("Error in starpv", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauTaitt(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1222 and may be overwritten at the next compilation.
Symbol
lux_iauTaitt_f(int32_t narg, int32_t ps[])
{
  int32_t iauTaitt(double, double, double*, double*);
  int32_t result = lux_i_dddpdp_iarq_0z11_f_(narg, ps, iauTaitt);
  if (result < 0)
    luxerror("Error in taitt", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauTaiut1(double, double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1228 and may be overwritten at the next compilation.
Symbol
lux_iauTaiut1_f(int32_t narg, int32_t ps[])
{
  int32_t iauTaiut1(double, double, double, double*, double*);
  int32_t result = lux_i_dT3dpdp_iaiqrq_0z122_f_(narg, ps, iauTaiut1);
  if (result < 0)
    luxerror("Error in taiut1", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauTaiutc(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1233 and may be overwritten at the next compilation.
Symbol
lux_iauTaiutc_f(int32_t narg, int32_t ps[])
{
  int32_t iauTaiutc(double, double, double*, double*);
  int32_t result = lux_i_dddpdp_iarq_0z11_f_(narg, ps, iauTaiutc);
  if (result < 0)
    luxerror("Error in taiutc", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauTcbtdb(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1238 and may be overwritten at the next compilation.
Symbol
lux_iauTcbtdb_f(int32_t narg, int32_t ps[])
{
  int32_t iauTcbtdb(double, double, double*, double*);
  int32_t result = lux_i_dddpdp_iarq_0z11_f_(narg, ps, iauTcbtdb);
  if (result < 0)
    luxerror("Error in tcbtdb", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauTcgtt(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1243 and may be overwritten at the next compilation.
Symbol
lux_iauTcgtt_f(int32_t narg, int32_t ps[])
{
  int32_t iauTcgtt(double, double, double*, double*);
  int32_t result = lux_i_dddpdp_iarq_0z11_f_(narg, ps, iauTcgtt);
  if (result < 0)
    luxerror("Error in tcgtt", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauTdbtcb(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1248 and may be overwritten at the next compilation.
Symbol
lux_iauTdbtcb_f(int32_t narg, int32_t ps[])
{
  int32_t iauTdbtcb(double, double, double*, double*);
  int32_t result = lux_i_dddpdp_iarq_0z11_f_(narg, ps, iauTdbtcb);
  if (result < 0)
    luxerror("Error in tdbtcb", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauTdbtt(double, double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1254 and may be overwritten at the next compilation.
Symbol
lux_iauTdbtt_f(int32_t narg, int32_t ps[])
{
  int32_t iauTdbtt(double, double, double, double*, double*);
  int32_t result = lux_i_dT3dpdp_iaiqrq_0z122_f_(narg, ps, iauTdbtt);
  if (result < 0)
    luxerror("Error in tdbtt", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauTr(double[3][3], double[3][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1259 and may be overwritten at the next compilation.
Symbol
lux_iauTr_f(int32_t narg, int32_t ps[])
{
  void iauTr(double[3][3], double[3][3]);
  int32_t result = lux_v_dp33T2_i33arq_01_f_(narg, ps, iauTr);
  if (result < 0)
    luxerror("Error in tr", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauTrxp(double[3][3], double[3], double[3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1264 and may be overwritten at the next compilation.
Symbol
lux_iauTrxp_f(int32_t narg, int32_t ps[])
{
  void iauTrxp(double[3][3], double[3], double[3]);
  int32_t result = lux_v_dp33dp3T2_i33aimqrcq_0T2_f_(narg, ps, iauTrxp);
  if (result < 0)
    luxerror("Error in trxp", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauTrxpv(double[3][3], double[2][3], double[2][3])
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1269 and may be overwritten at the next compilation.
Symbol
lux_iauTrxpv_f(int32_t narg, int32_t ps[])
{
  void iauTrxpv(double[3][3], double[2][3], double[2][3]);
  int32_t result = lux_v_dp33dp23T2_i33aim3p2qrcq_0T2_f_(narg, ps, iauTrxpv);
  if (result < 0)
    luxerror("Error in trxpv", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauTttai(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1274 and may be overwritten at the next compilation.
Symbol
lux_iauTttai_f(int32_t narg, int32_t ps[])
{
  int32_t iauTttai(double, double, double*, double*);
  int32_t result = lux_i_dddpdp_iarq_0z11_f_(narg, ps, iauTttai);
  if (result < 0)
    luxerror("Error in tttai", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauTttcg(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1279 and may be overwritten at the next compilation.
Symbol
lux_iauTttcg_f(int32_t narg, int32_t ps[])
{
  int32_t iauTttcg(double, double, double*, double*);
  int32_t result = lux_i_dddpdp_iarq_0z11_f_(narg, ps, iauTttcg);
  if (result < 0)
    luxerror("Error in tttcg", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauTttdb(double, double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1285 and may be overwritten at the next compilation.
Symbol
lux_iauTttdb_f(int32_t narg, int32_t ps[])
{
  int32_t iauTttdb(double, double, double, double*, double*);
  int32_t result = lux_i_dT3dpdp_iaiqrq_0z122_f_(narg, ps, iauTttdb);
  if (result < 0)
    luxerror("Error in tttdb", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauTtut1(double, double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1291 and may be overwritten at the next compilation.
Symbol
lux_iauTtut1_f(int32_t narg, int32_t ps[])
{
  int32_t iauTtut1(double, double, double, double*, double*);
  int32_t result = lux_i_dT3dpdp_iaiqrq_0z122_f_(narg, ps, iauTtut1);
  if (result < 0)
    luxerror("Error in ttut1", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauUt1tai(double, double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1297 and may be overwritten at the next compilation.
Symbol
lux_iauUt1tai_f(int32_t narg, int32_t ps[])
{
  int32_t iauUt1tai(double, double, double, double*, double*);
  int32_t result = lux_i_dT3dpdp_iaiqrq_0z122_f_(narg, ps, iauUt1tai);
  if (result < 0)
    luxerror("Error in ut1tai", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauUt1tt(double, double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1303 and may be overwritten at the next compilation.
Symbol
lux_iauUt1tt_f(int32_t narg, int32_t ps[])
{
  int32_t iauUt1tt(double, double, double, double*, double*);
  int32_t result = lux_i_dT3dpdp_iaiqrq_0z122_f_(narg, ps, iauUt1tt);
  if (result < 0)
    luxerror("Error in ut1tt", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauUt1utc(double, double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1309 and may be overwritten at the next compilation.
Symbol
lux_iauUt1utc_f(int32_t narg, int32_t ps[])
{
  int32_t iauUt1utc(double, double, double, double*, double*);
  int32_t result = lux_i_dT3dpdp_iaiqrq_0z122_f_(narg, ps, iauUt1utc);
  if (result < 0)
    luxerror("Error in ut1utc", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauUtctai(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1314 and may be overwritten at the next compilation.
Symbol
lux_iauUtctai_f(int32_t narg, int32_t ps[])
{
  int32_t iauUtctai(double, double, double*, double*);
  int32_t result = lux_i_dddpdp_iarq_0z11_f_(narg, ps, iauUtctai);
  if (result < 0)
    luxerror("Error in utctai", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     int32_t iauUtcut1(double, double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1320 and may be overwritten at the next compilation.
Symbol
lux_iauUtcut1_f(int32_t narg, int32_t ps[])
{
  int32_t iauUtcut1(double, double, double, double*, double*);
  int32_t result = lux_i_dT3dpdp_iaiqrq_0z122_f_(narg, ps, iauUtcut1);
  if (result < 0)
    luxerror("Error in utcut1", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauXy06(double, double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1327 and may be overwritten at the next compilation.
Symbol
lux_iauXy06_s(int32_t narg, int32_t ps[])
{
  void iauXy06(double, double, double*, double*);
  int32_t result = lux_v_dddpdp_iaoqoq_0z12_s_(narg, ps, iauXy06);
  if (result < 0)
    luxerror("Error in xy06", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauXys00a(double, double, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1334 and may be overwritten at the next compilation.
Symbol
lux_iauXys00a_s(int32_t narg, int32_t ps[])
{
  void iauXys00a(double, double, double*, double*, double*);
  int32_t result = lux_v_dddpT3_iaoqT3_0z1T3_s_(narg, ps, iauXys00a);
  if (result < 0)
    luxerror("Error in xys00a", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauXys00b(double, double, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1341 and may be overwritten at the next compilation.
Symbol
lux_iauXys00b_s(int32_t narg, int32_t ps[])
{
  void iauXys00b(double, double, double*, double*, double*);
  int32_t result = lux_v_dddpT3_iaoqT3_0z1T3_s_(narg, ps, iauXys00b);
  if (result < 0)
    luxerror("Error in xys00b", 0);
  return result;
}
#endif

#if HAVE_LIBSOFA_C
/// A function that wraps
///     void iauXys06a(double, double, double*, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on luxsofa.cc
// line 1348 and may be overwritten at the next compilation.
Symbol
lux_iauXys06a_s(int32_t narg, int32_t ps[])
{
  void iauXys06a(double, double, double*, double*, double*);
  int32_t result = lux_v_dddpT3_iaoqT3_0z1T3_s_(narg, ps, iauXys06a);
  if (result < 0)
    luxerror("Error in xys06a", 0);
  return result;
}
#endif

/// A function that wraps
///     void sincos(double, double*, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on sincos.cc
// line 29 and may be overwritten at the next compilation.
Symbol
lux_sincos_s(int32_t narg, int32_t ps[])
{
  void sincos(double, double*, double*);
  int32_t result = lux_v_ddpdp_iaoqoq_012_s_(narg, ps, sincos);
  if (result < 0)
    luxerror("Error in sincos", 0);
  return result;
}

/// A function that wraps
///     int32_t runord_d(double*, int32_t, int32_t, int32_t, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on strous3.cc
// line 2547 and may be overwritten at the next compilation.
Symbol
lux_runord_d_f(int32_t narg, int32_t ps[])
{
  int32_t runord_d(double*, int32_t, int32_t, int32_t, double*);
  int32_t result = lux_i_dpiT3dp_iaiirq_00T3_f_(narg, ps, runord_d);
  if (result < 0)
    luxerror("Error in runord", 0);
  return result;
}

/// A function that wraps
///     int32_t runmax_d(double*, int32_t, int32_t, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on strous3.cc
// line 2553 and may be overwritten at the next compilation.
Symbol
lux_runmax_d_f(int32_t narg, int32_t ps[])
{
  int32_t runmax_d(double*, int32_t, int32_t, double*);
  int32_t result = lux_i_dpiidp_iairq_00T2_f_(narg, ps, runmax_d);
  if (result < 0)
    luxerror("Error in RUNMAX", 0);
  return result;
}

/// A function that wraps
///     int32_t runmin_d(double*, int32_t, int32_t, double*)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on strous3.cc
// line 2559 and may be overwritten at the next compilation.
Symbol
lux_runmin_d_f(int32_t narg, int32_t ps[])
{
  int32_t runmin_d(double*, int32_t, int32_t, double*);
  int32_t result = lux_i_dpiidp_iairq_00T2_f_(narg, ps, runmin_d);
  if (result < 0)
    luxerror("Error in RUNMIN", 0);
  return result;
}

/// A function that wraps
///     int32_t unmod_slice_d(double*, size_t, size_t, double, double, double*, size_t, size_t)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on strous3.cc
// line 2592 and may be overwritten at the next compilation.
Symbol
lux_unmod_slice_d_f(int32_t narg, int32_t ps[])
{
  int32_t unmod_slice_d(double*, size_t, size_t, double, double, double*, size_t, size_t);
  int32_t result = lux_i_sdddsd_iaiiirq_000T333_f_(narg, ps, unmod_slice_d);
  if (result < 0)
    luxerror("Error in unmod", 0);
  return result;
}

/// A function that wraps
///     double hypot_stride(double*, size_t count, size_t stride)
/// suitable for use as a LUX subroutine or function.
//
// This glue function was generated by bindings.pl based on strous3.cc
// line 2603 and may be overwritten at the next compilation.
Symbol
lux_hypot_stride_f(int32_t narg, int32_t ps[])
{
  double hypot_stride(double*, size_t count, size_t stride);
  int32_t result = lux_d_sd_iaiarxq_000_2_f_(narg, ps, hypot_stride);
  if (result < 0)
    luxerror("Error in hypot", 0);
  return result;
}

void register_the_bindings()
{
  register_lux_f(lux_kepler_v_f, "kepler", 2, 2, "0meananomaly:1perifocalanomaly:0trueanomaly:2eccentricanomaly:4tau:8itercount");

#if HAVE_LIBCALCEPH
  int32_t lux_astron2(int32_t, int32_t []);
  register_lux_f(lux_astron2, "astron2", 2, 4, ":::equinox:1keepdims:~6ecliptical:2equatorial:4bare:~8polar:8xyz:16date:32conjspread");
#endif

  int32_t lux_error(int32_t, int32_t []);
  register_lux_s(lux_error, "error", 0, 2, "1store:2restore" );

  int32_t lux_bytfarr(int32_t, int32_t []);
  register_lux_f(lux_bytfarr, "bytfarr", 3, MAX_DIMS + 1, "%1%offset:1readonly:2swap");

  int32_t lux_bytfarr(int32_t, int32_t []);
  register_lux_f(lux_bytfarr, "uint8farr", 3, MAX_DIMS + 1, "%1%offset:1readonly:2swap");

  int32_t lux_intfarr(int32_t, int32_t []);
  register_lux_f(lux_intfarr, "intfarr", 3, MAX_DIMS + 1, "%1%offset:1readonly:2swap");

  int32_t lux_intfarr(int32_t, int32_t []);
  register_lux_f(lux_intfarr, "int16farr", 3, MAX_DIMS + 1, "%1%offset:1readonly:2swap");

  int32_t lux_lonfarr(int32_t, int32_t []);
  register_lux_f(lux_lonfarr, "lonfarr", 3, MAX_DIMS + 1, "%1%offset:1readonly:2swap");

  int32_t lux_lonfarr(int32_t, int32_t []);
  register_lux_f(lux_lonfarr, "int32farr", 3, MAX_DIMS + 1, "%1%offset:1readonly:2swap");

  int32_t lux_int64farr(int32_t, int32_t []);
  register_lux_f(lux_int64farr, "int64farr", 3, MAX_DIMS + 1, "%1%offset:1readonly:2swap");

  int32_t lux_generalfit2(int32_t, int32_t []);
  register_lux_f(lux_generalfit2, "fit3", 5, 7, "x:y:start:step:f:err:ithresh:1vocal");

  int32_t lux_setnan(int32_t, int32_t []);
  register_lux_f(lux_setnan, "setnan", 1, 2, NULL);

  int32_t lux_indgen_s(int32_t, int32_t []);
  register_lux_s(lux_indgen_s, "indgen", 1, 2, "*");

  int32_t lux_log2(int32_t, int32_t []);
  register_lux_f(lux_log2, "log2", 1, 1, nullptr);

  int32_t lux_runsum(int32_t, int32_t []);
  register_lux_f(lux_runsum, "runsum", 1, 3, "*");

  register_lux_f(lux_esmooth_asymmetric_f, "esmooth1", 1, 2, NULL);

  register_lux_f(lux_esmooth_symmetric_f, "esmooth2", 1, 2, NULL);

  register_lux_f(lux_gsl_fft_f, "fft", 1, 2, "1allaxes:2amplitudes");

  register_lux_s(lux_gsl_fft_s, "fft", 1, 2, "1allaxes:2amplitudes");

  register_lux_f(lux_gsl_fft_back_f, "fftb", 1, 2, "1allaxes:2amplitudes");

  register_lux_s(lux_gsl_fft_back_s, "fftb", 1, 2, "1allaxes:2amplitudes");

  register_lux_f(lux_hilbert_f, "hilbert", 1, 2, "1allaxes");

  register_lux_s(lux_hilbert_s, "hilbert", 1, 2, "1allaxes");

  int32_t lux_fft_expand(int32_t, int32_t []);
  register_lux_f(lux_fft_expand, "fftexpand", 2, 2, NULL);

  int32_t lux_hist(int32_t, int32_t []);
  register_lux_f(lux_hist, "hist", 1, 2, "1first:2ignorelimit:4increaselimit:8silent" );

  int32_t lux_gcommand(int32_t, int32_t []);
  register_lux_s(lux_gcommand, "gcommand", 1, 2, ":verbose");

  int32_t lux_gterm(int32_t, int32_t []);
  register_lux_s(lux_gterm, "gterm", 1, 1, "");

  int32_t lux_gplot(int32_t, int32_t []);
  register_lux_s(lux_gplot, "gplot", 1, 13, ":::linetype:pointtype:dashtype:color:legend:breaks:xtitle:ytitle:ztitle:title:0lii:2loi:4lio:6loo:0liii:2loii:4lioi:6looi:8liio:10loio:12lioo:14looo");

  int32_t lux_goplot(int32_t, int32_t []);
  register_lux_s(lux_goplot, "goplot", 1, 9, ":::linetype:pointtype:dashtype:color:legend:breaks");

  int32_t lux_gaplot(int32_t, int32_t []);
  register_lux_s(lux_gaplot, "gaplot", 0, 13, ":::linetype:pointtype:dashtype:color:legend:breaks:xtitle:ytitle:ztitle:title:0lii:2loi:4lio:6loo:0liii:2loii:4lioi:6looi:8liio:10loio:12lioo:14looo");

  int32_t lux_gnutv(int32_t, int32_t []);
  register_lux_s(lux_gnutv, "gtv", 1, 1, NULL);

  int32_t lux_gnuplot3d(int32_t, int32_t []);
  register_lux_s(lux_gnuplot3d, "gplot3d", 1, 10, ":::xtitle:ytitle:ztitle:title:rotx:rotz:contours:1flat:0lii:2loi:4lio:6loo:0liii:2loii:4lioi:6looi:8liio:10loio:12lioo:14looo");

  int32_t lux_gnucontour(int32_t, int32_t []);
  register_lux_s(lux_gnucontour, "gcontour", 1, 1, ":1equalxy:2image");

#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauBi00_f, "bi00", 0, 0, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauBp00_s, "bp00", 4, 4, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauBp06_s, "bp06", 4, 4, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauBpn2xy_s, "bpn2xy", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2i00a_f, "c2i00a", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2i00b_f, "c2i00b", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2i06a_f, "c2i06a", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2ibpn_f, "c2ibpn", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2ixy_f, "c2ixy", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2ixys_f, "c2ixys", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2s_f, "c2s", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2t00a_f, "c2t00a", 4, 4, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2t00b_f, "c2t00b", 4, 4, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2t06a_f, "c2t06a", 4, 4, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2tcio_f, "c2tcio", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2teqx_f, "c2teqx", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2tpe_f, "c2tpe", 5, 5, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauC2txy_f, "c2txy", 5, 5, 0);

#endif
#if HAVE_LIBSOFA_C
  int32_t lux_iauCal2jd(int32_t, int32_t []);
  register_lux_f(lux_iauCal2jd, "cal2jd", 1, 1, 0);
#endif

#if HAVE_LIBSOFA_C
  int32_t lux_iauDat(int32_t, int32_t []);
  register_lux_f(lux_iauDat, "dat", 0, 1, "1valid");
#endif

#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauDtdb_f, "dtdb", 5, 5, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_do_iauEe00_f, "ee00", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauEe00a_f, "ee00a", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauEe00b_f, "ee00b", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauEe06a_f, "ee06a", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauEect00_f, "eect00", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauEform_f, "eform", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauEo06a_f, "eo06a", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauEors_f, "eors", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauEpb_f, "epb", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  int32_t lux_iauEpb2jd(int32_t, int32_t []);
  register_lux_f(lux_iauEpb2jd, "epb2jd", 1, 1, 0);
#endif

#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauEpj_f, "epj", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  int32_t lux_iauEpj2jd(int32_t, int32_t []);
  register_lux_f(lux_iauEpj2jd, "epj2jd", 1, 1, 0);
#endif

#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauEpv00_s, "epv00", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauEqeq94_f, "eqeq94", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauEra00_f, "era00", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFad03_f, "fad03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFae03_f, "fae03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFaf03_f, "faf03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFaju03_f, "faju03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFal03_f, "fal03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFalp03_f, "falp03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFama03_f, "fama03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFame03_f, "fame03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFane03_f, "fane03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFaom03_f, "faom03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFapa03_f, "fapa03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFasa03_f, "fasa03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFaur03_f, "faur03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFave03_f, "fave03", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauFk52h_s, "fk52h", 12, 12, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauFk5hip_s, "fk5hip", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauFk5hz_s, "fk5hz", 5, 5, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauFw2m_f, "fw2m", 4, 4, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauFw2xy_s, "fw2xy", 6, 6, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGc2gd_f, "gc2gd", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGc2gde_f, "gc2gde", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGd2gc_f, "gd2gc", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGd2gce_f, "gd2gce", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGmst00_f, "gmst00", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGmst06_f, "gmst06", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGmst82_f, "gmst82", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGst00a_f, "gst00a", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGst00b_f, "gst00b", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGst06_f, "gst06", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGst06a_f, "gst06a", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauGst94_f, "gst94", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauH2fk5_s, "h2fk5", 12, 12, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauHfk5z_s, "hfk5z", 7, 7, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauIr_f, "ir", 0, 0, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauJd2cal_f, "jd2cal", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauNum00a_f, "num00a", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauNum00b_f, "num00b", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauNum06a_f, "num06a", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauNumat_f, "numat", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauNut00a_s, "nut00a", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauNut00b_s, "nut00b", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauNut06a_s, "nut06a", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauNut80_s, "nut80", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauNutm80_f, "nutm80", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauObl06_f, "obl06", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauObl80_f, "obl80", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauP06e_s, "p06e", 17, 17, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauP2s_f, "p2s", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPap_f, "pap", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPas_f, "pas", 4, 4, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPb06_s, "pb06", 4, 4, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPdp_f, "pdp", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPfw06_s, "pfw06", 5, 5, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPlan94_f, "plan94", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPm_f, "pm", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPmat00_f, "pmat00", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPmat06_f, "pmat06", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPmat76_f, "pmat76", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPn_s, "pn", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPn00_s, "pn00", 9, 9, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPn00a_s, "pn00a", 9, 9, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPn00b_s, "pn00b", 9, 9, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPn06_s, "pn06", 9, 9, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPn06a_s, "pn06a", 9, 9, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPnm00a_f, "pnm00a", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPnm00b_f, "pnm00b", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPnm06a_f, "pnm06a", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPnm80_f, "pnm80", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPom00_f, "pom00", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPr00_s, "pr00", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPrec76_s, "prec76", 5, 5, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPv2s_s, "pv25", 7, 7, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPvdpv_f, "pvdpv", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPvm_s, "pvm", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauPvstar_s, "pvstar", 7, 7, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPvxpv_f, "pvxpv", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauPxp_f, "pxp", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauRm2v_f, "rm2v", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauRxp_f, "rxp", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauRxr_f, "rxr", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauRv2m_f, "rv2m", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauRx_s, "rx", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauRxpv_f, "rxpv", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauRy_s, "ry", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauRz_s, "rz", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_do_iauS00_f, "s00", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauS00a_f, "s00a", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauS00b_f, "s00b", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_do_iauS06_f, "s06", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauS06a_f, "s06a", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauS2c_f, "S2C", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauS2p_f, "s2p", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauS2pv_f, "s2pv", 6, 6, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauSepp_f, "sepp", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauSeps_f, "seps", 4, 4, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauSp00_f, "sp00", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauStarpm_s, "starpm", 14, 14, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauStarpv_f, "starpv", 6, 6, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTaitt_f, "taitt", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTaiut1_f, "taiut1", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTaiutc_f, "taiutc", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTcbtdb_f, "tcbtdb", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTcgtt_f, "tcgtt", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTdbtcb_f, "tdbtcb", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTdbtt_f, "tdbtt", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTr_f, "tr", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTrxp_f, "trxp", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTrxpv_f, "trxpv", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTttai_f, "tttai", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTttcg_f, "tttcg", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTttdb_f, "tttdb", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauTtut1_f, "ttut1", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauUt1tai_f, "ut1tai", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauUt1tt_f, "ut1tt", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauUt1utc_f, "ut1utc", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauUtctai_f, "utctai", 1, 1, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_f(lux_iauUtcut1_f, "utcut1", 2, 2, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauXy06_s, "xy06", 3, 3, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauXys00a_s, "xys00a", 4, 4, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauXys00b_s, "xys00b", 4, 4, 0);

#endif
#if HAVE_LIBSOFA_C
  register_lux_s(lux_iauXys06a_s, "xys06a", 4, 4, 0);

#endif
  int32_t lux_matrix_product(int32_t, int32_t []);
  register_lux_f(lux_matrix_product, "mproduct", 2, 2, "0inner:1outer");

  int32_t lux_svd(int32_t, int32_t []);
  register_lux_s(lux_svd, "svd", 4, 4, NULL);

  int32_t lux_transpose_matrix(int32_t, int32_t []);
  register_lux_f(lux_transpose_matrix, "transpose", 1, 1, NULL);

  int32_t lux_diagonal_matrix(int32_t, int32_t []);
  register_lux_f(lux_diagonal_matrix, "mdiagonal", 1, 1, NULL);

  int32_t lux_read_image_oiio(int32_t, int32_t []);
  register_lux_f(lux_read_image_oiio, "readimage", 1, 1, NULL);

  int32_t lux_randome(int32_t, int32_t []);
  register_lux_f(lux_randome, "randome", 3, MAX_DIMS, "%1%limit:scale");

  register_lux_s(lux_sincos_s, "sincos", 3, 3, NULL);

  int32_t lux_distr(int32_t, int32_t []);
  register_lux_f(lux_distr, "distr", 2, 2, "2ignorelimit:4increaselimit" );

  int32_t lux_find(int32_t, int32_t []);
  register_lux_f(lux_find, "find", 2, 3, "1data_monotonic:2at_or_past");

  int32_t lux_noop(int32_t, int32_t []);
  register_lux_s(lux_noop, "noop", 0, 0, nullptr);

  int32_t lux_tolookup(int32_t, int32_t []);
  register_lux_s(lux_tolookup, "tolookup", 2, 4, "1one");

  int32_t lux_monotone_interpolation(int32_t, int32_t []);
  register_lux_f(lux_monotone_interpolation, "monotoneinterpolate", 3, 3, "1none:2circle:4square:8wide:16full");

  register_lux_f(lux_runord_d_f, "runord", 3, 3, NULL);

  register_lux_f(lux_runmax_d_f, "RUNMAX", 2, 2, NULL);

  register_lux_f(lux_runmin_d_f, "RUNMIN", 2, 2, NULL);

  register_lux_f(lux_unmod_slice_d_f, "unmod", 2, 4, ":axis:period:average");

  register_lux_f(lux_hypot_stride_f, "hypot", 1, 2, ":axis");

  int32_t lux_ssfc_to_polar(int32_t, int32_t []);
  register_lux_f(lux_ssfc_to_polar, "ssfctopolar", 1, 2, 0);

  int32_t lux_polar_to_ssfc(int32_t, int32_t []);
  register_lux_f(lux_polar_to_ssfc, "polartossfc", 1, 2, 0);

  int32_t lux_findspans(int32_t, int32_t []);
  register_lux_f(lux_findspans, "findspans", 1, 1, "1cycle");

  int32_t lux_commonfactors(int32_t, int32_t []);
  register_lux_s(lux_commonfactors, "commonfactors", 3, 4, NULL);

#if HAVE_LIBGSL
  int32_t lux_planetpermutationchanges(int32_t, int32_t []);
  register_lux_f(lux_planetpermutationchanges, "planetpermutationchanges", 3, 3, "1verbose");
#endif

#if HAVE_LIBGSL
  int32_t lux_permutationnumber(int32_t, int32_t []);
  register_lux_f(lux_permutationnumber, "permutationnumber", 1, 2, "0rank:1index:0linear:2circular");
#endif

#if HAVE_LIBGSL
  int32_t lux_permutation(int32_t, int32_t []);
  register_lux_f(lux_permutation, "permutation", 2, 2, "0rank:1index:0linear:2circular");
#endif

#if HAVE_LIBGSL
  int32_t lux_permutationdistance(int32_t, int32_t []);
  register_lux_f(lux_permutationdistance, "permutationdistance", 2, 2, "0rank:1index:0linear:2circular");
#endif

#if HAVE_LIBGSL
  int32_t lux_factorial(int32_t, int32_t []);
  register_lux_f(lux_factorial, "factorial", 1, 1, NULL);
#endif

  int32_t lux_decompose_2d_median3(int32_t, int32_t []);
  register_lux_s(lux_decompose_2d_median3, "decompose2dmedian3", 3, 3, NULL);

  int32_t lux_compose_2d(int32_t, int32_t []);
  register_lux_s(lux_compose_2d, "compose2d", 3, 3, NULL);

  int32_t lux_div(int32_t, int32_t []);
  register_lux_f(lux_div, "div", 2, 2, NULL);

  int32_t lux_byte(int32_t, int32_t []);
  register_lux_f(lux_byte, "byte", 1, 1, "*");

  int32_t lux_byte(int32_t, int32_t []);
  register_lux_f(lux_byte, "uint8", 1, 1, "*");

  int32_t lux_word(int32_t, int32_t []);
  register_lux_f(lux_word, "word", 1, 1, "*");

  int32_t lux_word(int32_t, int32_t []);
  register_lux_f(lux_word, "int16", 1, 1, "*");

  int32_t lux_long(int32_t, int32_t []);
  register_lux_f(lux_long, "long", 1, 1, "*");

  int32_t lux_long(int32_t, int32_t []);
  register_lux_f(lux_long, "int32", 1, 1, "*");

  int32_t lux_int64(int32_t, int32_t []);
  register_lux_f(lux_int64, "int64", 1, 1, "*");

  int32_t lux_floor(int32_t, int32_t []);
  register_lux_f(lux_floor, "floor", 1, 2, nullptr);

  int32_t lux_ceil(int32_t, int32_t []);
  register_lux_f(lux_ceil, "ceil", 1, 2, nullptr);

  int32_t lux_bytarr(int32_t, int32_t []);
  register_lux_f(lux_bytarr, "bytarr", 1, MAX_DIMS, nullptr);

  int32_t lux_bytarr(int32_t, int32_t []);
  register_lux_f(lux_bytarr, "uint8arr", 1, MAX_DIMS, nullptr);

  int32_t lux_intarr(int32_t, int32_t []);
  register_lux_f(lux_intarr, "intarr", 1, MAX_DIMS, nullptr);

  int32_t lux_intarr(int32_t, int32_t []);
  register_lux_f(lux_intarr, "int16arr", 1, MAX_DIMS, nullptr);

  int32_t lux_lonarr(int32_t, int32_t []);
  register_lux_f(lux_lonarr, "lonarr", 1, MAX_DIMS, nullptr);

  int32_t lux_lonarr(int32_t, int32_t []);
  register_lux_f(lux_lonarr, "int32arr", 1, MAX_DIMS, nullptr);

  int32_t lux_int64arr(int32_t, int32_t []);
  register_lux_f(lux_int64arr, "int64arr", 1, MAX_DIMS, nullptr);

}
